import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;
import java.util.Scanner;

/**
 * Matt DePero CSE283 B Dr. Jianhui Yue
 * 
 * @author deperomm
 * 
 *         This class acts as a TCP server with multi-threading for each
 *         connection made to it. Upon connection, it generates a random range
 *         of number and an random number that the has to try and guess
 * 
 * 
 */
public class Question_04_Server {

	// Socket variables
	ServerSocket serverSocket, managerServerSocket;
	boolean serverIsOn;
	int port;

	// Thread variables
	int threadID;

	// used for random number generation
	Random rand = new Random();

	/**
	 * Constructor that initializes and runs the server
	 */
	public Question_04_Server() {

		getServerInfo();

		setUpServer();

		runServer();

	}// end constructor

	/**
	 * prompts user for info for the server
	 */
	private void getServerInfo() {
		Scanner input = new Scanner(System.in);

		System.out.print("What port would you like to use? ");
		port = Integer.parseInt(input.nextLine());

		input.close();

	}// end getServerInfo

	/**
	 * sets up the server with the info
	 */
	private void setUpServer() {

		try {
			serverSocket = new ServerSocket(port);
			managerServerSocket = new ServerSocket(port + 1);
		} catch (IOException ioe) {
			System.out.println("Could not create server socket on port " + port
					+ ". " + ioe.getMessage());

			System.exit(-1);
		}

		serverIsOn = true;

	}// end setupserver

	/**
	 * Runs the server. Creates a new thread for each subsequent connection
	 */
	private void runServer() {

		while (serverIsOn) {

			try {

				Socket socketToClient = serverSocket.accept();

				Socket managerSocket = managerServerSocket.accept();

				// once both connections established, start both threads

				threadID++;

				ClientThread singleClientThread = new ClientThread(
						socketToClient, threadID);
				singleClientThread.start();

				// send the manager thread a link to it's client thread

				ManagerThread singleManagerThread = new ManagerThread(
						singleClientThread, managerSocket, threadID);
				singleManagerThread.start();

			} catch (IOException ioe) {
				System.out
						.println("Exception encountered on accept. Ignoring. Stack Trace :");
				ioe.printStackTrace();
			}

		}

		try {
			serverSocket.close();
			managerServerSocket.close();
			System.out.println("Server Stopped");
		} catch (Exception ioe) {
			System.out.println("Problem stopping server");
			System.exit(-1);
		}

	}// end runserver

	/**
	 * An inner class for running each thread for each connection
	 * 
	 * @author matt
	 * 
	 */
	public class ClientThread extends Thread {

		// thread variables
		Socket clientSocket;
		int threadID;
		boolean threadRunning;

		// game variables
		int min, max, num, numGuesses,numRightGuesses;
		int maxGuessesAllowed = 5;

		/**
		 * Constructor for the socket thread.
		 * 
		 * @param clientSocket
		 *            The socket that connects this thread to the client
		 * @param threadID
		 *            The unique ID for this thread on the server
		 */
		public ClientThread(Socket clientSocket, int threadID) {

			this.clientSocket = clientSocket;

			this.threadID = threadID;

			threadRunning = false;
			
			numGuesses = 0;
			numRightGuesses = 0;

		}// end constructor

		/**
		 * starts the thread process and loops until completed
		 */
		public void run() {

			threadRunning = true;

			System.out.println("Starting Thread.\n  Session: " + threadID
					+ "\n  Client Address: "
					+ clientSocket.getInetAddress().getHostName());

			BufferedReader inputFromClient = null;
			PrintWriter outputToClient = null;

			try {

				// set up input output buffers for the client
				inputFromClient = new BufferedReader(new InputStreamReader(
						clientSocket.getInputStream()));

				outputToClient = new PrintWriter(new OutputStreamWriter(
						clientSocket.getOutputStream()));

				// run the thread
				while (threadRunning) {

					// read in message from client
					String clientMessage = inputFromClient.readLine();
					System.out.println("Thread " + threadID + " Said: "
							+ clientMessage);

					// check that the upper level server wasn't stopped while
					// running the thread
					if (!serverIsOn) {
						// The server was stopped. Quit this thread
						System.out.print("Ending thread " + threadID
								+ ", server was stopped.");
						outputToClient.println("Sorry, the server was stopped");
						outputToClient.flush();
						threadRunning = false;

					}

					// based on the message received, create the message to
					// return

					// messageToSend will be sent to the client and printed on
					// the server console
					String messageToSend;

					if (clientMessage.equalsIgnoreCase("quit")) {

						threadRunning = false;

						messageToSend = "Quitting process due to stop message: "
								+ clientMessage;

					} else if (clientMessage
							.equalsIgnoreCase("Hi Server, let's play a game.")) {

						setNewRange();

						System.out.println("Thread " + threadID
								+ " Number to Guess is: " + num);

						messageToSend = "Ok, let's play. Guess a number between "
								+ min + " and " + max + " (inclusive)";

					} else if (clientMessage.matches("^\\d+$")) {
						// client sent a number, check guess

						if (Integer.parseInt(clientMessage) == num) {

							numGuesses++;
							numRightGuesses++;
							setNewRange();
							messageToSend = "You guessed it! New Game. Guess a number between "
								+ min + " and " + max + " (inclusive)";

						} else {

							if (numGuesses + 1 >= maxGuessesAllowed) {

								messageToSend = "Sorry, that was your last guess. You lose, the number was "
										+ num + ". The game is done.";
								threadRunning = false;

							} else {
								numGuesses++;
								int guess = Integer.parseInt(clientMessage);
								messageToSend = String
										.format("That's not it,  the number is %s than that.",
												(num > guess) ? "greater"
														: "less");
							}
						}

					} else {

						// all other input mark as invalid
						messageToSend = "Invalid input, try again.";

					}

					// send the actual reply to the server and console
					outputToClient.println(messageToSend);
					outputToClient.flush();
					System.out.println("Thread " + threadID + " Sent: "
							+ messageToSend);

				}

				// handle exceptions
			} catch (Exception e) {
				e.printStackTrace();
			} finally {

				try {
					inputFromClient.close();
					outputToClient.close();
					clientSocket.close();
					System.out.println("Stopped thread " + threadID);
				} catch (IOException ioe) {
					ioe.printStackTrace();
				}
			}

		}// end run()
		
		/**
		 * This method sets the classes variables to a new game
		 */
		private void setNewRange(){
			
			// creates a random range of numbers
			min = rand.nextInt(10);

			max = rand.nextInt(40 - min) + min;

			num = rand.nextInt(max - min) + min;
			
		}// end setNewRange()

	}// end inner class ClientThread

	/**
	 * An inner class for managing a channel
	 * 
	 * @author matt
	 * 
	 */
	public class ManagerThread extends Thread {

		// thread variables
		ClientThread clientThread;
		Socket managerSocket;
		int threadID;
		boolean threadRunning;

		/**
		 * Constructor for the socket thread.
		 * 
		 * @param clientThread
		 *            A link to the clientThread that this thread manages
		 * @param clientSocket
		 *            The socket that connects this thread to the client
		 * @param threadID
		 *            The unique ID for this thread on the server
		 */
		public ManagerThread(ClientThread clientThread, Socket managerSocket,
				int threadID) {

			this.clientThread = clientThread;

			this.managerSocket = managerSocket;

			this.threadID = threadID;

			threadRunning = false;

		}// end constructor

		/**
		 * starts the thread process and loops until completed
		 */
		public void run() {

			threadRunning = true;

			System.out.println("Starting Manager Thread.\n  Session: "
					+ threadID + "\n  Client Address: "
					+ managerSocket.getInetAddress().getHostName());

			BufferedReader inputFromClient = null;
			PrintWriter outputToClient = null;

			try {

				// set up input output buffers for the client
				inputFromClient = new BufferedReader(new InputStreamReader(
						managerSocket.getInputStream()));

				outputToClient = new PrintWriter(new OutputStreamWriter(
						managerSocket.getOutputStream()));

				// run the thread
				while (threadRunning) {

					// read in message from client
					String clientMessage = inputFromClient.readLine();
					System.out.println("Manager Thread " + threadID + " Said: "
							+ clientMessage);

					// check that the upper level server wasn't stopped while
					// running the thread
					if (!serverIsOn || !clientThread.threadRunning) {

						// The server was stopped. Quit this thread
						System.out.print("Ending manager thread " + threadID
								+ ", server was stopped.");
						outputToClient
								.println("Sorry, the server was stopped or the "
										+ "client thread was stopped");
						outputToClient.flush();
						threadRunning = false;

					}

					// based on the message received, create the message to
					// return

					// messageToSend will be sent to the client and printed on
					// the server console
					String messageToSend;

					if (clientMessage.equalsIgnoreCase("quit")) {

						threadRunning = false;

						clientThread.threadRunning = false;

						messageToSend = "Quitting process due to stop message: "
								+ clientMessage;

					} else if (clientMessage.matches("^\\d+$")) {

						// client manager sent a number, adjust max possible
						// guesses

						clientThread.maxGuessesAllowed = Integer
								.parseInt(clientMessage);

						messageToSend = "Changed max number of guesses to "
								+ Integer.parseInt(clientMessage);

					} else if (clientMessage
							.equalsIgnoreCase("get success rate")) {

						// client maanger wants the success rate on this channel

//						messageToSend = "Success rate on this channel is " +
//							clientThread.numGuesses/;
						// TODO
						messageToSend = "";

					} else {

						// all other input mark as invalid
						messageToSend = "Invalid input, try again.";

					}

					// send the actual reply to the server and console
					outputToClient.println(messageToSend);
					outputToClient.flush();
					System.out.println("Thread " + threadID + " Sent: "
							+ messageToSend);

				}

				// handle exceptions
			} catch (Exception e) {
				e.printStackTrace();
			} finally {

				try {
					inputFromClient.close();
					outputToClient.close();
					managerSocket.close();
					System.out.println("Stopped manager thread " + threadID);
				} catch (IOException ioe) {
					ioe.printStackTrace();
				}
			}

		}// end run()

	}// end inner class ClientThread

	/**
	 * main method initializes the server
	 * 
	 * @param args
	 */
	public static void main(String[] args) {

		new Question_03_Server();

	}// end main

}// end class
